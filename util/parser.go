// Copyright 2010 Abiola Ibrahim <abiola89@gmail.com>. All rights reserved.
// Use of this source code is governed by New BSD License
// http://www.opensource.org/licenses/bsd-license.php
// The content and logo is governed by Creative Commons Attribution 3.0
// The mascott is a property of Go governed by Creative Commons Attribution 3.0
// http://creativecommons.org/licenses/by/3.0/

package util

import (
	"errors"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path"
	"strings"
)

var (
	comment = "//Generated by gopages%s, do not edit\n//This file will be overwritten during build\n\n"
	method  = `func Render%s(conn http.ResponseWriter, request *http.Request){
					conn.Header().Set("Content-Type", "text/html")
					print := func(toPrint ...interface{}){
						fmt.Fprint(conn, toPrint...)
					}
					formValue := func(keyToGet string) string{
						return request.FormValue(keyToGet)
					}
					print(""); formValue("")// prevent initialization runtime error

			`
	importstring = "\nimport(\n"
	printstring  = "fmt.Fprint(conn, `%s`)\n"

	//directory where generated codes will be stored
	DIR = path.Join(os.Getenv("PWD"), "pages")
)

//Page type
type Page struct {
	imports       []string
	page          string
	content       string
	generatedPage string
	parsed        bool
}

// create a new instance of page
func NewPage(page string) (p *Page, err error) {
	p = new(Page)
	p.page = page
	f, err := os.Open(page)
	f.Close()
	return
}

// parse the page and stores the resulting string in the buffer
// use ParseToFIle instead to write to string to file
func (this *Page) Parse() (err error) {
	data, err := ioutil.ReadFile(this.page) //reads file into memory
	if err != nil {
		return
	}
	importsParser := NewQuoteParser(string(data), "{{", "}}")
	imports, p, er := importsParser.Next()
	if er != nil {
		err = er
		return
	}
	content := importsParser.String()
	if len(strings.TrimSpace(p)) > 0 {
		content = p
	}
	this.imports = strings.Fields(imports)
	buffer := NewStringBuilder(fmt.Sprintf("%spackage %s\n", fmt.Sprintf(comment, " from "+this.page), "pages"))
	buffer.Append(importstring)
	for _, im := range this.imports {
		if im != "net/http" && im != "fmt" {
			buffer.Append(fmt.Sprintf("\"%s\"\n", im))
		}
	}
	buffer.Append("\t\"net/http\"\n\t\"fmt\"\n)\n")
	pg := strings.Split(this.page, "/")
	pg = strings.Split(strings.Join(pg, ""), ".")
	buffer.Append(fmt.Sprintf(method, strings.Join(pg, "")))
	codeParser := NewQuoteParser(content, "<?go", "?>")
	err = codeParser.Parse()
	if err != nil {
		err = errors.New("error from " + this.page + " :" + err.Error())
		return
	}
	codes, html := codeParser.Parsed(), codeParser.Outer()
	for i, code := range codes {
		buffer.Append(fmt.Sprintf(printstring, html[i]))
		buffer.Append(fmt.Sprintf("%s\n", code))
	}
	buffer.Append("\n}\n")
	this.content = buffer.Content()
	return nil
}

// behaves like Parse but writes to the corresponding output file
func (this *Page) ParseToFile() (err error) {
	if this.parsed {
		return
	}
	err = this.Parse()
	if err != nil {
		return
	}
	tmp := strings.Split(this.page, "/")
	tmp = strings.Split(strings.Join(tmp, ""), ".")
	file := strings.Join(tmp, "")
	this.generatedPage = path.Join(DIR, file+".go")
	err = ioutil.WriteFile(this.generatedPage, []byte(this.content), 0666)
	if err != nil {
		return
	}
	this.parsed = true
	err = Format(this.generatedPage)
	return
}

// formats the source code using gofmt
func Format(source string) (err error) {
	//gofmt := os.Getenv("GOBIN")
	gofmt, _ := exec.LookPath("gofmt")
	if len(gofmt) == 0 {
		return errors.New("gofmt not found in PATH")
	}
	fd := []*os.File{os.Stdin, os.Stdout, os.Stderr}
	file := source
	//	dir, file := path.Split(source)
	//println(source, dir, file)
	//	id, err := os.ForkExec(gofmt, []string{"", "-w", file}, os.Environ(), dir, fd)
	process, err := os.StartProcess(gofmt, []string{"", "-w", file}, &os.ProcAttr{Env: os.Environ(), Files: fd})
	if err != nil {
		println(err.Error())
		return
	} else {
		process.Wait()
		//os.Wait(id, 0)
	}
	return nil
}

//codes that will be generated
const (
	httphandler = "http.Handle(\"/%s\", http.HandlerFunc(Render%s))\n"
	initfunc    = "func init%s(){\n%s\n%s\n}\n"
	startserver = `func Run(address string) (err error){
						println("gopages serving on", address)
						err = http.ListenAndServe(address, nil)
						return
					}
					`
	forbidden = `
		func RenderGoPagesForbidden(conn http.ResponseWriter, request *http.Request){
			conn.WriteHeader(403)
			conn.Write([]byte("<h1>403 Forbidden</h1>"))
		}
		`
	fileHandler = `
		http.Handle("/", http.HandlerFunc(func(conn http.ResponseWriter, request *http.Request){
			if request.URL.Path == "/"{
				defaultPage := "%s"
				if strings.TrimSpace(defaultPage) != ""{
					http.Redirect(conn, request, defaultPage, http.StatusFound)
				}
				return
			}
			val := "%s" + request.URL.Path
			_,err := os.Open(val)
			if err!=nil{
				conn.WriteHeader(404)
				conn.Write([]byte("<h1>404 Not Found</h1>"))
				return
			}
			http.ServeFile(conn, request, val)
		}))
		`
)

//add handlers to specified pages in settings file
func AddHandlers(pages []string) (err error) {
	initOthers := func(k, i int) string {
		if k <= len(pages) {
			return fmt.Sprintf("init%d()\n", i+1)
		}
		return ""
	}
	for i, j, k := 0, 0, 1000; j < len(pages); i++ {
		p := fmt.Sprintf("handler%d.go", i)
		if i == 0 {
			p = "handler.go"
		}
		file := path.Join(DIR, p)
		l := len(pages) - j
		var slice []string
		if l < 1000 {
			slice = pages[j:]
		} else {
			slice = pages[j:k]
		}
		buffer := NewStringBuilder(fmt.Sprintf("%spackage %s\n", fmt.Sprintf(comment, ""), "pages"))
		buffer.Append(importstring)
		imports := []string{"os", "strings", "net/http"}
		for _, im := range imports {
			buffer.Append(fmt.Sprintf("\"%s\"\n", im))
		}
		buffer.Append("\n)\n")
		handlers := NewStringBuilder("")
		for _, page := range slice {
			pg := strings.Split(page, "/")
			pg = strings.Split(strings.Join(pg, ""), ".")
			p := strings.Join(pg, "")
			l0 := len(path.Ext(page))
			wp := page[1 : len(page)-l0]
			l0 = len(Config["srcfolder"][0])
			wp = wp[l0:]
			handlers.Append(fmt.Sprintf(httphandler, wp, p))
			handlers.Append(fmt.Sprintf(httphandler, page[l0+1:], "GoPagesForbidden"))
		}
		if k > len(pages) {
			buffer.Append(startserver)
			buffer.Append(forbidden)
			handlers.Append(fmt.Sprintf(fileHandler, Config["default"][0], Config["srcfolder"][0]))
			handlers.Append(fmt.Sprintf(httphandler, Config["srcfolder"][0], "GoPagesForbidden"))
			handlers.Append(fmt.Sprintf(httphandler, "pages", "GoPagesForbidden"))
		}
		st := fmt.Sprintf("%d", i)
		if i == 0 {
			st = ""
		}
		buffer.Append(fmt.Sprintf(initfunc, st, handlers.Content(), initOthers(k, i)))
		err = ioutil.WriteFile(file, []byte(buffer.Content()), 0666)
		if err != nil {
			return
		}
		err = Format(file)
		if err != nil {
			return
		}
		j += 1000
		k += 1000
	}
	return
}
